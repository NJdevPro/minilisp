Loading examples/nqueens.lisp
DEBUG: Checking function call: (defun list (x . y) (cons x y))
DEBUG: Checking function call: (defmacro let1 (var val . body) (cons (cons (quote lambda) (cons (list var) body)) (list val)))
DEBUG: Checking function call: (defmacro and (expr . rest) (if rest (list (quote if) expr (cons (quote and) rest)) expr))
DEBUG: Checking function call: (defmacro or (expr . rest) (if rest (let1 var (gensym) (list (quote let1) var expr (list (quote if) var var (cons (quote or) rest)))) expr))
DEBUG: Checking function call: (defmacro when (expr . body) (cons (quote if) (cons expr (list (cons (quote progn) body)))))
DEBUG: Checking function call: (defmacro unless (expr . body) (cons (quote if) (cons expr (cons () body))))
DEBUG: Checking function call: (defun any (lis pred) (when lis (or (pred (car lis)) (any (cdr lis) pred))))
DEBUG: Checking function call: (defun map (lis fn) (when lis (cons (fn (car lis)) (map (cdr lis) fn))))
DEBUG: Checking function call: (defun nth (lis n) (if (= n 0) (car lis) (nth (cdr lis) (- n 1))))
DEBUG: Checking function call: (defun nth-tail (lis n) (if (= n 0) lis (nth-tail (cdr lis) (- n 1))))
DEBUG: Checking function call: (defun %iota (m n) (unless (<= n m) (cons m (%iota (+ m 1) n))))
DEBUG: Checking function call: (defun iota (n) (%iota 0 n))
DEBUG: Checking function call: (defun make-list (len init) (unless (= len 0) (cons init (make-list (- len 1) init))))
DEBUG: Checking function call: (defun for-each (lis fn) (or (not lis) (progn (fn (car lis)) (for-each (cdr lis) fn))))
DEBUG: Checking function call: (defun make-board (size) (map (iota size) (lambda (_) (make-list size (quote x)))))
DEBUG: Checking function call: (defun get (board x y) (nth (nth board x) y))
DEBUG: Checking function call: (defun set (board x y) (setcar (nth-tail (nth board x) y) (quote Q)))
DEBUG: Checking function call: (defun clear (board x y) (setcar (nth-tail (nth board x) y) (quote x)))
DEBUG: Checking function call: (defun set? (board x y) (eq (get board x y) (quote Q)))
DEBUG: Checking function call: (defun print (board) (if (not board) (quote $) (println (car board)) (print (cdr board))))
DEBUG: Checking function call: (defun conflict? (board x y) (any (iota x) (lambda (n) (or (set? board n y) (let1 z (+ y (- n x)) (and (<= 0 z) (set? board n z))) (let1 z (+ y (- x n)) (and (< z board-size) (set? board n z)))))))
DEBUG: Checking function call: (defun %solve (board x) (if (= x board-size) (progn (print board) (println (quote $))) (for-each (iota board-size) (lambda (y) (unless (conflict? board x y) (set board x y) (%solve board (+ x 1)) (clear board x y))))))
DEBUG: Checking function call: (defun solve (board) (println (quote start)) (%solve board 0) (println (quote done)))
DEBUG: Checking function call: (define board-size 4)
DEBUG: Checking function call: (define board (make-board board-size))
DEBUG: Checking function call: (make-board board-size)
DEBUG: Checking tail position for: (make-board board-size) in context: null
DEBUG: apply_func called with tail_call = 0
DEBUG: Checking function call: (map (iota size) (lambda (_) (make-list size (quote x))))
DEBUG: Checking tail position for: (map (iota size) (lambda (_) (make-list size (quote x)))) in context: ((map (iota size) (lambda (_) (make-list size (quote x)))))
DEBUG: Tail call optimization for: (map (iota size) (lambda (_) (make-list size (quote x))))
DEBUG: Checking function call: (iota size)
DEBUG: Checking tail position for: (iota size) in context: null
DEBUG: apply_func called with tail_call = 0
DEBUG: Checking function call: (%iota 0 n)
DEBUG: Checking tail position for: (%iota 0 n) in context: ((%iota 0 n))
DEBUG: Tail call optimization for: (%iota 0 n)
DEBUG: apply_func called with tail_call = 1
DEBUG: apply_func called with tail_call = 0
DEBUG: Checking function call: (cons (quote if) (cons expr (cons () body)))
DEBUG: Checking function call: (quote if)
DEBUG: Checking function call: (cons expr (cons () body))
DEBUG: Checking function call: (cons () body)
DEBUG: Checking function call: (<= n m)
DEBUG: Checking function call: (con